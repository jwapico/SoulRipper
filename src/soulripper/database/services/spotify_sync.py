import logging
from typing import Optional, List, Tuple, Dict
from dateutil.parser import isoparse
import datetime

from sqlalchemy.ext.asyncio import AsyncSession

from soulripper.spotify import SpotifyClient
from ..schemas import TrackData
from ..models import Playlists
from ..repositories import PlaylistsRepository

logger = logging.getLogger(__name__)

async def update_db_with_all_playlists(sql_session: AsyncSession, spotify_client: SpotifyClient):
    all_playlists_metadata = await spotify_client.get_all_playlists()
    if all_playlists_metadata:
        for playlist_metadata in all_playlists_metadata:
            await update_db_with_spotify_playlist(sql_session, spotify_client, playlist_metadata)

async def update_db_with_spotify_playlist(sql_session: AsyncSession, spotify_client: SpotifyClient, spotify_playlist_metadata: dict) -> None:
    logger.info(f"Updating database with tracks from playlist {spotify_playlist_metadata['name']}...")

    # get the TrackData for the playlist
    playlist_tracks = await spotify_client.get_playlist_tracks(spotify_playlist_metadata['id'])
    relevant_tracks_data: List[Tuple[TrackData, datetime.datetime]] = get_track_data_from_playlist(playlist_tracks)

    # create the playlist row
    playlist_row = await PlaylistsRepository.add_playlist(sql_session, spotify_playlist_metadata['id'], spotify_playlist_metadata['name'], spotify_playlist_metadata['description'])

    # add the track data to the playlist and commit
    await PlaylistsRepository.add_tracks_to_playlist(sql_session, relevant_tracks_data, playlist_row)
    await sql_session.commit()

# TODO: this function takes a while to run, we should find a way to check if there any changes before calling it
async def update_db_with_spotify_liked_tracks(spotify_client: SpotifyClient, sql_session: AsyncSession) -> Optional[Playlists]:
    # get the TrackData for the users liked tracks
    liked_tracks_data = await spotify_client.get_liked_tracks()
    relevant_tracks_data: List[Tuple[TrackData, datetime.datetime]] = get_track_data_from_playlist(liked_tracks_data)

    # create the playlist row
    liked_playlist_row = await PlaylistsRepository.add_playlist(sql_session, spotify_id=None, name="SPOTIFY_LIKED_SONGS", description="User liked songs on Spotify - This playlist is generated by SoulRipper")

    # add each track in the users liked songs to the database if it doesn't already exist
    await PlaylistsRepository.add_tracks_to_playlist(sql_session, relevant_tracks_data, liked_playlist_row)

    # commit and return the row
    await sql_session.commit()
    return liked_playlist_row

def get_track_data_from_playlist(tracks: List[Dict]) -> List[Tuple[TrackData, datetime.datetime]]:
    relevant_data = []
    for track in tracks:
        if track["track"] is None:
            logger.warning(f"track field of spotify track empty for some reason, skipping...\nempty data: {track}")
            continue

        spotify_id = track["track"]["id"]
        title = track["track"]["name"]
        artists = [(artist["name"], artist["id"]) for artist in track["track"]["artists"]]
        album = track["track"]["album"]["name"]
        release_date = track["track"]["album"]["release_date"]
        explicit = track["track"]["explicit"]
        track_added_date = track["added_at"]
        track_added_date = isoparse(track_added_date)

        track_data = TrackData(
            spotify_id=spotify_id,
            title=title,
            artists=artists,
            album=album,
            release_date=release_date if release_date != "" else None,
            explicit=explicit,
            filepath=None,
            comments=None
        )

        relevant_data.append((track_data, track_added_date))
    
    return relevant_data