from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Tuple
import logging
import datetime
import os

from soulripper.database.services import update_db_with_spotify_liked_tracks, get_track_data_from_playlist, update_db_with_spotify_playlist
from soulripper.database.repositories import TracksRepository, PlaylistsRepository, ArtistsRepository
from soulripper.database.schemas import TrackData, PlaylistData
from soulripper.spotify import SpotifyClient
from soulripper.downloaders import SoulseekDownloader, download_track_ytdlp

logger = logging.getLogger(__name__)

# TODO: a lot of this code (and sync services) need to be refactored
# TODO: should this be a class?
# TODO: downloads should happen concurrently: https://www.reddit.com/r/learnpython/comments/rlcbid/asyncio_make_2_functions_run_concurrently_without/

async def download_track(slskd_client: SoulseekDownloader, search_query: str, output_path: str, youtube_only: bool = False, max_retries: int = 5) -> str:
    """
    Downloads a track from soulseek or youtube, only downloading from youtube if the query is not found on soulseek

    Args:
        search_query (str): the song to download, can be a search query
        output_path (str): the directory to download the song to

    Returns:
        str: the path to the downloaded file
    """
    if youtube_only:
        return await download_track_ytdlp(search_query, output_path)

    download_path = await slskd_client.download_track(search_query, output_path, max_retries)

    if download_path is None:
        download_path = await download_track_ytdlp(search_query, output_path)

    return download_path

async def download_liked_songs(slskd_client: SoulseekDownloader, spotify_client: SpotifyClient, sql_session: AsyncSession, output_path: str, youtube_only: bool) -> bool:
    # TODO: this function takes a while to run, we should find a way to check if there any changes before calling it
    # add the users liked songs to the database
    liked_playlist = await update_db_with_spotify_liked_tracks(spotify_client, sql_session)

    if liked_playlist is None:
        logger.error("No playlist row was not returned by update_db_with_spotify_liked_tracks")
        return False
    
    liked_playlist_tracks_rows = await PlaylistsRepository.get_playlist_track_rows(sql_session, liked_playlist.id)

    if liked_playlist_tracks_rows is None:
        logger.error("Could not retreive liked playlist tracks from database.")
        return False

    try:
        # TODO: maybe we should be using the download_track function with a TrackData instead of the search query, hard to get TrackData though since also need to get artists
        #    - we should write a get_trackdata classmethod that will do all this for us
        for playlist_track_row in liked_playlist_tracks_rows:
            track_id = playlist_track_row.track_id
            track_row = await TracksRepository.get_track_from_id(sql_session=sql_session, track_id=track_id)

            if track_row is not None:
                if track_row.filepath is None:
                    artist_rows = await ArtistsRepository.get_artists_for_track_id(sql_session, track_id)
                    if artist_rows is not None:
                        track_artists = ", ".join([artist_row.name for artist_row in artist_rows])

                        search_query = f"{track_row.title} - {track_artists}"

                        filepath = await download_track(slskd_client, search_query, output_path, youtube_only)
                        track_row.filepath = filepath
                        await sql_session.commit()

    except Exception as e:
        await sql_session.rollback()
        raise e

    return True
    
# TODO: bruhhhhhhhhhhh the spotify api current_user_saved_tracks() function doesn't return local files FUCK SPOTIFYU there has to be a workaround
async def download_liked_tracks_from_spotify_data(slskd_client: SoulseekDownloader, spotify_client: SpotifyClient, sql_session: AsyncSession, output_path: str):
    liked_tracks_data = await spotify_client.get_liked_tracks()
    relevant_tracks_data: List[Tuple[TrackData, datetime.datetime]] = get_track_data_from_playlist(liked_tracks_data)

    track_rows_and_data = []
    for track, _ in relevant_tracks_data:
        existing_track = await TracksRepository.get_existing_track(sql_session, track)
        if existing_track is None:
            filepath = await download_from_track_data(slskd_client, track, output_path)
            track.filepath = filepath

            track_row = await TracksRepository.add_track(sql_session, track)
            track_rows_and_data.append((track_row, track))

    await PlaylistsRepository.add_playlist(sql_session, spotify_id=None, name="SPOTIFY_LIKED_SONGS", description="User liked songs on Spotify - This playlist is generated by SoulRipper")

# TODO: this is where better search will happen - construct query from trackdata
async def download_from_track_data(slskd_client: SoulseekDownloader, track: TrackData, output_path: str) -> str:
    artists = ', '.join([artist[0] for artist in track.artists]) if track.artists else ""
    search_query = f"{track.title} - {artists}"
    download_path = await download_track(slskd_client, search_query, output_path)
    return download_path

async def download_all_playlists(sql_session: AsyncSession, slskd_client: SoulseekDownloader, output_path: str, yt_only: bool, max_retries: int):
    playlists_data = await PlaylistsRepository.get_all_playlists(sql_session)

    if playlists_data:
        for playlist_data in playlists_data:
            if playlist_data.id:
                await download_playlist(sql_session, playlist_data.id, slskd_client, output_path, yt_only, max_retries)

async def download_playlist(sql_session: AsyncSession, playlist_id: int, slskd_client: SoulseekDownloader, output_path: str, yt_only: bool, max_retries: int) -> None:
    """
    Downloads all the tracks of a playlist in the database

    Args:
        sql_session (AsyncSession): The sqlalchemy AsyncSession
        playlist_id (int): The id of the playlist to download
    """

    playlist_track_rows = await PlaylistsRepository.get_playlist_track_rows(sql_session, playlist_id)

    if playlist_track_rows is None:
        logger.error("Could not retreive liked playlist tracks from database.")
        return
    
    playlist_track_data = await PlaylistsRepository.get_track_data(sql_session, playlist_id)

    if playlist_track_data:
        for track in playlist_track_data:
            search_query = f"{track.title} - {', '.join([artist[0] for artist in track.artists]) if track.artists else ''}"
            await download_track(slskd_client, search_query, output_path, yt_only, max_retries)