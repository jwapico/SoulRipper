from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Tuple
import logging
import datetime
import os

from soulripper.database.services import update_db_with_spotify_liked_tracks, get_track_data_from_playlist
from soulripper.database.repositories import TracksRepository, PlaylistsRepository, ArtistsRepository
from soulripper.database.schemas import TrackData
from soulripper.spotify import SpotifyClient
from soulripper.downloaders import SoulseekDownloader, download_track_ytdlp

logger = logging.getLogger(__name__)

# TODO: a lot of this code (and sync services) need to be refactored

async def download_from_search_query(slskd_client: SoulseekDownloader, search_query: str, output_path: str, youtube_only: bool = False, max_retries: int = 5) -> str:
    """
    Downloads a track from soulseek or youtube, only downloading from youtube if the query is not found on soulseek

    Args:
        search_query (str): the song to download, can be a search query
        output_path (str): the directory to download the song to

    Returns:
        str: the path to the downloaded file
    """
    if youtube_only:
        return await download_track_ytdlp(search_query, output_path)

    download_path = await slskd_client.download_track(search_query, output_path, max_retries)

    if download_path is None:
        download_path = await download_track_ytdlp(search_query, output_path)

    return download_path

async def download_liked_songs(slskd_client: SoulseekDownloader, spotify_client: SpotifyClient, sql_session: AsyncSession, output_path: str, youtube_only: bool) -> bool:
    # TODO: this function takes a while to run, we should find a way to check if there any changes before calling it
    # add the users liked songs to the database
    liked_playlist = await update_db_with_spotify_liked_tracks(spotify_client, sql_session)

    if liked_playlist is None:
        logger.error("No playlist row was not returned by update_db_with_spotify_liked_tracks")
        return False
    
    liked_playlist_tracks_rows = await PlaylistsRepository.get_playlist_track_rows(sql_session, liked_playlist.id)

    if liked_playlist_tracks_rows is None:
        logger.error("Could not retreive liked playlist tracks from database.")
        return False

    try:
        # TODO: maybe we should be using the download_track function with a TrackData instead of the search query, hard to get TrackData though since also need to get artists
        #    - we should write a get_trackdata classmethod that will do all this for us
        for playlist_track_row in liked_playlist_tracks_rows:
            track_id = playlist_track_row.track_id
            track_row = await TracksRepository.get_track_from_id(sql_session=sql_session, track_id=track_id)

            if track_row is not None:
                if track_row.filepath is None:
                    artist_rows = await ArtistsRepository.get_artists_for_track_id(sql_session, track_id)
                    if artist_rows is not None:
                        track_artists = ", ".join([artist_row.name for artist_row in artist_rows])

                        search_query = f"{track_row.title} - {track_artists}"

                        filepath = await download_from_search_query(slskd_client, search_query, output_path, youtube_only)
                        track_row.filepath = filepath
                        await sql_session.commit()

    except Exception as e:
        await sql_session.rollback()
        raise e

    return True
    
# TODO: bruhhhhhhhhhhh the spotify api current_user_saved_tracks() function doesn't return local files FUCK SPOTIFYU there has to be a workaround
async def download_liked_tracks_from_spotify_data(slskd_client: SoulseekDownloader, spotify_client: SpotifyClient, sql_session: AsyncSession, output_path: str):
    liked_tracks_data = await spotify_client.get_liked_tracks()
    relevant_tracks_data: List[Tuple[TrackData, datetime.datetime]] = get_track_data_from_playlist(liked_tracks_data)

    track_rows_and_data = []
    for track, _ in relevant_tracks_data:
        existing_track = await TracksRepository.get_existing_track(sql_session, track)
        if existing_track is None:
            filepath = await download_track(slskd_client, track, output_path)
            track.filepath = filepath

            track_row = await TracksRepository.add_track(sql_session, track)
            track_rows_and_data.append((track_row, track))

    await PlaylistsRepository.add_playlist(sql_session, spotify_id=None, name="SPOTIFY_LIKED_SONGS", description="User liked songs on Spotify - This playlist is generated by SoulRipper")

async def download_playlist_from_spotify_url(slskd_client: SoulseekDownloader, spotify_client: SpotifyClient, sql_session: AsyncSession, playlist_url: str, output_path: str):
    """
    Downloads a playlist from spotify

    Args:
        playlist_url (str): the url of the playlist
        output_path (str): the directory to download the songs to
    """

    playlist_id = spotify_client.extract_playlist_id_from_url(playlist_url)
    playlist_tracks = await spotify_client.get_playlist_tracks(playlist_id)
    playlist_info = await spotify_client.get_playlist_info(playlist_id)

    if playlist_info:
        output_path = os.path.join(output_path, playlist_info["name"])
        os.makedirs(output_path, exist_ok=True)

        relevant_tracks_data: List[Tuple[TrackData, datetime.datetime]] = get_track_data_from_playlist(playlist_tracks)

        track_rows_and_data = []
        for track_data, _ in relevant_tracks_data:
            existing_track_row = await TracksRepository.get_existing_track(sql_session, track_data)
            # TODO: need better searching !
            if existing_track_row is None:
                filepath = await download_track(slskd_client, track_data, output_path)
                track_data.filepath = filepath
                new_track_row = await TracksRepository.add_track(sql_session, track_data)
                track_rows_and_data.append((new_track_row, track_data))
            else:
                logger.info(f"Track ({track_data.title} - {track_data.artists}) already exists in the database, skipping download.")
                if existing_track_row.filepath is None:
                    existing_track_row.filepath = await download_track(slskd_client, track_data, output_path)
                track_rows_and_data.append((existing_track_row, track_data))

        await PlaylistsRepository.add_playlist(sql_session, playlist_id, playlist_info["name"], playlist_info["description"])
        await sql_session.commit()

# TODO: this is where better search will happen - construct query from trackdata
async def download_track(slskd_client: SoulseekDownloader, track: TrackData, output_path: str) -> str:
    artists = ', '.join([artist[0] for artist in track.artists]) if track.artists else ""
    search_query = f"{track.title} - {artists}"
    download_path = await download_from_search_query(slskd_client, search_query, output_path)
    return download_path