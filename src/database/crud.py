import os

from database.trackdata import TrackData
import database.models as SoulDB
import utils.files

# TODO: this function technically kinda works but we need a better way to extract metadata from the files - most files (all downloaded by yt-dlp) have None for all fields except filepath :/
#   - maybe we can extract info from filename
#   - we should probably populate metadata using TrackData from database or Spotify API - this is a lot of work dgaf rn lol
def scan_music_library(sql_session, music_dir: str):
    """
    Adds all songs in the music directory to the database

    Args:
        music_dir (str): the directory to add songs from
    """
    print(f"Scanning music library at {music_dir}...")

    for root, dirs, files in os.walk(music_dir):
        for file in files:
            # TODO: these extensions should be configured with the config file (still need to implement config file </3)
            if file.endswith(".mp3") or file.endswith(".flac") or file.endswith(".wav"):
                filepath = os.path.abspath(os.path.join(root, file))
                existing_track = SoulDB.Tracks.get_existing_track(sql_session, TrackData(filepath=filepath))
                if existing_track is None:
                    add_new_track_to_db(sql_session, filepath)
                else:
                    print(f"track with filepath: {filepath} already found in database, skipping")
    sql_session.commit()

def add_new_track_to_db(sql_session, filepath: str):
    if not os.path.exists(filepath):
        print(f"File {filepath} does not exist, skipping...")
        return

    file_track_data: TrackData = utils.files.extract_file_metadata(filepath)

    if file_track_data is None:
        print(f"No metadata found in file {filepath}, skipping...")
        file_track_data = TrackData(filepath=filepath, comments="WARNING: Error while extracting metadata. This likely means the file is corrupted or empty")

    print(f"Found track with data: {file_track_data}, adding to database...")

    existing_track = SoulDB.Tracks.get_existing_track(sql_session, file_track_data)
    if existing_track is None:
        SoulDB.Tracks.add_track(sql_session, file_track_data)
        sql_session.commit()

def update_db_with_spotify_playlist(sql_session, spotify_client, playlist_metadata):
    print(f"Updating database with tracks from playlist {playlist_metadata['name']}...")

    playlist_tracks = spotify_client.get_playlist_tracks(playlist_metadata['id'])
    relevant_tracks_data: list[TrackData] = spotify_client.get_data_from_playlist(playlist_tracks)

    # create and flush the playlist since we need its id for the playlist_tracks association table
    playlist_row = sql_session.query(SoulDB.Playlists).filter_by(spotify_id=playlist_metadata['id']).first()
    if playlist_row is None:
        playlist_row = SoulDB.Playlists.add_playlist(sql_session, playlist_metadata['id'], playlist_metadata['name'], playlist_metadata['description'])
        sql_session.add(playlist_row)
        sql_session.flush()

    # add each track in the playlist to the database if it doesn't already exist
    # for track_data in relevant_tracks_data:
    add_track_data_to_playlist(sql_session, relevant_tracks_data, playlist_row)
    sql_session.commit()

# TODO: this function takes a while to run, we should find a way to check if there any changes before calling it
def update_db_with_spotify_liked_tracks(spotify_client, sql_session):
    liked_tracks_data = spotify_client.get_liked_tracks()
    relevant_tracks_data: list[TrackData] = spotify_client.get_track_data_from_playlist(liked_tracks_data)

    liked_playlist = sql_session.query(SoulDB.Playlists).filter_by(name="SPOTIFY_LIKED_SONGS").first()
    if liked_playlist is None:
        liked_playlist = SoulDB.Playlists.add_playlist(sql_session, spotify_id=None, name="SPOTIFY_LIKED_SONGS", description="User liked songs on Spotify - This playlist is generated by SoulRipper")
        sql_session.add(liked_playlist)
        sql_session.flush()

    # add each track in the users liked songs to the database if it doesn't already exist
    add_track_data_to_playlist(sql_session, relevant_tracks_data, liked_playlist)

    sql_session.commit()
    return liked_playlist

# TODO: we should be using lists not sets, a playlist can have multiple identical tracks and thats okay
def add_track_data_to_playlist(sql_session, track_data_list: list[TrackData], playlist_row: SoulDB.Playlists):
    existing_spotify_ids = set(
        spotify_id for (spotify_id,) in sql_session.query(SoulDB.Tracks.spotify_id).filter(SoulDB.Tracks.spotify_id.isnot(None))
    )
    existing_non_spotify_tracks = set(
        (title, album, filepath) for (title, album, filepath) in sql_session.query(
            SoulDB.Tracks.title, SoulDB.Tracks.album, SoulDB.Tracks.filepath
        ).filter(SoulDB.Tracks.spotify_id.is_(None))
    )

    new_tracks = set()
    seen_spotify_ids = set()
    seen_non_spotify = set()

    for track_data in track_data_list:
        if track_data.spotify_id:
            if track_data.spotify_id in existing_spotify_ids or track_data.spotify_id in seen_spotify_ids:
                continue
            seen_spotify_ids.add(track_data.spotify_id)
        else:
            key = (track_data.title, track_data.album, track_data.filepath)
            if key in existing_non_spotify_tracks or key in seen_non_spotify:
                continue
            seen_non_spotify.add(key)
        new_tracks.add(track_data)
            
    SoulDB.Tracks.bulk_add_tracks(sql_session,new_tracks)
    
    existing_assoc_keys = set(
        (playlist_id, track_id)
        for playlist_id, track_id in sql_session.query(
            SoulDB.PlaylistTracks.playlist_id,
            SoulDB.PlaylistTracks.track_id
        ).all()
    )
    for track_data in track_data_list:
        track = SoulDB.Tracks.get_existing_track(sql_session,track_data)
        if track:
            assoc = SoulDB.PlaylistTracks(track_id=track.id, playlist_id=playlist_row.id, added_at=track.date_liked_spotify)
            if (assoc.playlist_id, assoc.track_id) not in existing_assoc_keys:
                existing_assoc_keys.add(assoc)
                playlist_row.playlist_tracks.append(assoc)
        else:
            print("Error")

def search_for_track(sql_session, track_title):
    results = sql_session.query(SoulDB.Tracks).filter(
        SoulDB.Tracks.title.ilike(f"%{track_title}%")
    ).all()

    return results

def modify_track(sql_session, track_id, new_track_data: TrackData):
    existing_track = sql_session.query(SoulDB.Tracks).filter_by(id=track_id).one()
    
    existing_track.spotify_id = new_track_data.spotify_id if new_track_data.spotify_id is not None else existing_track.spotify_id
    existing_track.filepath = new_track_data.filepath if new_track_data.filepath is not None else existing_track.filepath
    existing_track.title = new_track_data.title if new_track_data.title is not None else existing_track.title
    existing_track.album = new_track_data.album if new_track_data.album is not None else existing_track.album
    existing_track.release_date = new_track_data.release_date if new_track_data.release_date is not None else existing_track.release_date
    existing_track.explicit = new_track_data.explicit if new_track_data.explicit is not None else existing_track.explicit
    existing_track.date_liked_spotify = new_track_data.date_liked_spotify if new_track_data.date_liked_spotify is not None else existing_track.date_liked_spotify
    existing_track.comments = new_track_data.comments if new_track_data.comments is not None else existing_track.comments

def remove_track(sql_session, track_id) -> bool :
    existing_track = sql_session.query(SoulDB.Tracks).filter_by(id=track_id).one()

    if existing_track:
        sql_session.delete(existing_track)
        sql_session.flush()
        print("Successfully removed the track")
        return True
    else:
        print("Could not find the track you were trying to remove")
        return False